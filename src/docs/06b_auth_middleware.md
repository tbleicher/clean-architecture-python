# 6b. Authentication Middleware

With the `login` mutation implemented in the last step [06a. Authentication Token](./06a_authentication.md) the user can request an _access token_ that identifies them in further requests. When this token is included in a request header, the server can extract it and use the information within to identify the user. This feature is usually implemented as _middleware_ in the web framework. In this chapter we will add such a middleware to our FastAPI server.

## Token Middleware

You can find some background on [FastAPI middleware on their website](https://fastapi.tiangolo.com/tutorial/middleware/). Here is the first paragraph outlining the sequence of a middleware call (the emphasis is mine and not the one used on the FastAPI web site):

1. It takes **each** request that comes to your application.
2. It can then **do something to** that request or run any needed code.
3. Then it passes the request to be processed by the rest of the application (by some path operation).
4. It then takes the response generated by the application (by some path operation).
5. It can do something to that response or run any needed code.
6. Then it returns the response.

For our authentication use case the first two points are important:

Firstly, middleware runs for _every single request_ that the server receives. It is common to implement authentication middleware in a way that rejects a request if a token is not provided. We are not going to do that. In our _Clean Architecture_ approach only the use cases can decide if a request is authorised or not. If we want to expose some endpoints to unauthorised users we have to let all requests past the HTTP and GraphQL layers to reach the use cases.

Note that you can reject requests without token if your application does not contain any publicly available endpoints. You have to supply a different method for the user to obtain the token, like a 3rd party service.

Secondly, middleware can update the request before it is processed by a route handler. Our middleware will extract the user information from a potential token and attach it to the request so that the following layers do not have to deal with the token details but can just check if details of the requesting user are available or not.

I think this makes best use of the potential of a token: It provides us with basic user information but avoids a DB lookup to load this information. If a use case requires additional information beyond the token data we can implement the lookup within the use case itself.

### Implementing Middleware in FastAPI

Based on the FastAPI code example a _middleware_ receives two arguments:

- the _request_
- a _call_next_ function

We are only interested in processing the request. The _response_ we return unchanged. In FastAPI middleware is implemented as a _decorator_. The setup for our authentication middleware needs to be at the top level of the app in `main.py`:

```python
# app/main.py

@app.middleware("http")
async def session(request: Request, call_next):
    try:
        request = await get_token_user(request)
    except Exception as exc:
        logging.error(exc)

    response = await call_next(request)
    return response
```

The processing of the request is implemented in the `get_token_user` function:

1. We try to extract a token from the `authorization` header of the request. If there is no header we return an empty string.
2. We set up another use case to interpret the token and return a `SessionUser` object. If we get one, it is added to the `request.state`.
3. If anything goes wrong we set `request.state.user` to `None`. So we can always check `request.state.user` without AttributeError, but still need to check that the user object is not `None`.
4. Finally we return the request object for further processing.

```python
# app/adapters/http/middleware/get_token_user.py

from app.domain.auth.use_cases import GetSessionUserUseCase

def get_token_from_header(request: Request) -> str:
    """return auth token from request headers"""
    try:
        auth_header = request.headers["authorization"]
    except KeyError:
        return ""

    if auth_header.lower().startswith("bearer "):
        return auth_header.split(" ")[1]

    return auth_header

async def get_token_user(request: Request) -> Request:
    """add session user from auth token to request"""
    try:
        token = get_token_from_header(request)
        use_case = GetSessionUserUseCase()
        request.state.user = await use_case.execute(token)
    except KeyError:
        request.state.user = None

    return request
```

### _GetSessionUserUseCase_

The _GetSessionUserUseCase_ implements no logic. The `execute` method just passes the token to the `get_session_user_from_token` method of the AuthService to process. If this call fails - for example, because the token is expired - we would receive no session user entity so the return type has to be specified as `Optional[SessionUser]`.

The method is set up as `async` although we are not doing anything that requires `await`ing. Should you wish to look up extra data for the user from a DB or other external source you can implement it here without blocking other requests.

```python
# app/domain/auth/use_cases/session.py
class GetSessionUserUseCase:
    """identify and return user from request token"""

    @inject
    def __init__(
        self,
        auth_service: AuthServiceInterface = Provide[AppDependencies.services.auth_service],  # type: ignore
    ):
        self.auth_service: AuthServiceInterface = auth_service

    async def execute(self, token: str) -> Optional[SessionUser]:
        """return list of groups in the same organization"""
        session_user = self.auth_service.get_session_user_from_token(token)
        # optional: implement async user data lookup here
        return session_user
```

### Getting the Session User from the Token

When we created our token in the `AuthService.get_token` method, we used an instance of the _SessionUser_ entity to generate the user data for the token payload. We can reverse this and create an new _SessionUser_ instance from the token data.

At first we need to decode the raw token string with the correct signing secret to verify that it is one of our own tokens we are processing. When we receive the decoded data (a nested Python `dict`) we can find the user data under the `user` key. Based on this data we can instantiate a new _SessionUser_ object and return it to the caller.

All this should work without a hitch if we are dealing with one of our own access tokens. If there is an error it's a sign of an incorrect or incomplete token string. In that case we just return `None` and the request will be treated like an anonymous requests without authenticated user.

```python
# app/domain/auth/service.py
    def get_session_user_from_token(self, token: str) -> Optional[SessionUser]:
        """extract user data from session token"""
        algorithm = self.config["algorithm"]
        secret = self.config["secret"]

        try:
            decoded = jwt.decode(token, secret, algorithms=[algorithm])
            session_user = SessionUser(**decoded["user"])
            return session_user
        except Exception:
            return None
```

We now have our session user that is handed back to the middleware where it is set up as the `request.state.user` object. Every GraphQL resolver that needs to provide the requesting user to a use case can get check this attribute and pass it as argument to the `execute` method.

## Profile Query

For a quick example we can add a `profile` endpoint to our schema that returns the current user profile or `null` if the user is not logged in.

We will add a new `UserProfile` entity to identify the content of the returned data clearly. We could just return a `SessionUser` object but that would undermine the meaning of the data type and we would have to change it if we decide in the future that we want to add some extra data to the profile.

```python
# app/domain/users/entities.py

class UserProfile(BaseModel):
    """profile data for the currently logged in user"""

    id: str
    email: str
    organization_id: str
    is_admin: bool

    class Config:
        allow_mutation = False
```

To save time we won't implement a lot of logic to generate the profile data. We will just return the data that is provided by the session user object. This object is passed in as argument `current_user` to the `execute` method. Therefore we don't have any dependencies that need to be injected in the use case constructor.

```python
from typing import Optional
from ..entities import SessionUser, UserProfile

class GetUserProfileUseCase:
    """return the current user's profile data"""

    async def execute(
        self, current_user: Optional[SessionUser] = None
    ) -> Optional[UserProfile]:
        if not current_user:
            return None

        return UserProfile(**current_user.dict())
```

The `UserProfile` entity requires a corresponding GraphQL type. It has the same set of attributes and we know that all of them will be present so we can mark them as required fields. While the attributes of the `UserProfile` type can be required, the `profile` field itself must be optional. If an unauthenticated visitor queries the `profile` endpoint they should just receive `null` instead of an error.

```python
# app/adapters/graphql/types/users.py

class UserProfile(graphene.ObjectType):
    class Meta:
        description = "Details of the current user"

    id = graphene.ID(required=True)
    email = graphene.String(required=True)
    organization_id = graphene.String(required=True)
    is_admin = graphene.Boolean(required=True)

# app/adapters/graphql/query.py
class Query(graphene.ObjectType):
    # ... other attributes and methods

    profile = graphene.Field(types.UserProfile)

    @staticmethod
    async def resolve_profile(parent, info):
        return await resolvers.get_user_profile(info)
```

In the `resolve_profile` method we call a new `get_user_profile` resolver to interact with the use case. The `get_user_profile` resolver will not only set up and execute the use case. It also needs to extract the `SessionUser` object from the GraphQL execution `info` - if it is present.

In our middleware we attach the user data as `request.state.user`. In the `info` object we can find this attribute under `info.context["request"]["state"]["user"]`. We can be sure that this key is set because the middleware either sets it to the `SessionUser` object or `None` if the token is not provided or invalid.

```python
# app/adapters/graphql/resolvers/users.py
from app.domain.users.entities import UserProfile
from app.domain.users.use_cases import GetUserProfileUseCase

async def get_user_profile(info) -> Optional[UserProfile]:
    """get use profile from current user in session info"""
    current_user = info.context["request"]["state"]["user"]
    use_case = GetUserProfileUseCase()
    return await use_case.execute(current_user)

# ... other resolvers
```

`info.context["request"]["state"]["user"]` is quite a mouth full and we have to add the user data to (almost) all of our endpoints. We can define a helper function to get the current user from the `info` object:

```python
# app/adapters/graphql/helpers.py
from typing import Any, Optional
from app.domain.users.entities import SessionUser

def get_current_user(info: Any) -> Optional[SessionUser]:
    current_user = info.context["request"]["state"]["user"]
    return current_user
```

## Testing

The `profile` query endpoint is now in place and we can make our first query. Unfortunately, the `GraphiQL` interface that FastAPI/Starlette provides does not have an option to set request headers. So from here on we have to rely on our automated integration tests to set the right authentication header for our queries. In this section we will set up Pytest fixtures to obtain authentication tokens and update our tests to use them.

### Manual Testing

Before we update our test suite, let's first verify that the endpoint is working as expected. We can use the command line tool `curl` to send our credentials to the `login` endpoint and obtain a token as response:

```bash
$ curl \
  -H "Content-Type: application/json" \
  -d '{ "query": "mutation { login(input: { email: \"admin@example.com\", password: \"password\" }) { token } }" }' \
  http://localhost:8000/graphql

{"data":{"login":{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJVU0VSLUFETSIsInVzZXIiOnsiaWQiOiJVU0VSLUFETSIsImVtYWlsIjoiYWRtaW5AZXhhbXBsZS5jb20iLCJvcmdhbml6YXRpb25faWQiOiIiLCJpc19hZG1pbiI6dHJ1ZX0sImV4cCI6MTYxNzc5MTkyOX0.-qQf1pUAYD_sVmDYgvwKb7ti86yY4WDcSrcTapZ4iOs"}}}%
```

Now we can use this token string as a `Authorization` header in a new request to the `profile` endpoint. We have to prefix the token with `Bearer ` to match the expectations of the header format.

```bash
$ curl \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJVU0VSLUFETSIsInVzZXIiOnsiaWQiOiJVU0VSLUFETSIsImVtYWlsIjoiYWRtaW5AZXhhbXBsZS5jb20iLCJvcmdhbml6YXRpb25faWQiOiIiLCJpc19hZG1pbiI6dHJ1ZX0sImV4cCI6MTYxNzc5MTkyOX0.-qQf1pUAYD_sVmDYgvwKb7ti86yY4WDcSrcTapZ4iOs" \
  -d '{ "query": "query { profile { id email } }" }' \
  http://localhost:8000/graphql

{"data":{"profile":{"id":"USER-ADM","email":"admin@example.com"}}}%
```

As expected, the returned data identifies the user as `admin@example.com`. Our `profile` endpoint works!

### Authentication Token for Automated Testing

Now that we have confirmed that the `profile` query endpoint works we can add automated tests. For this endpoint we need to test two scenarios:

- **[GQL-PFL-01]** `profile` returns `null` when queried without token
- **[GQL-PFL-02]** `profile` returns the correct profile data for an authenticated user

The first test is easy. We just use our test client to make a query to the `profile` endpoint. Since we don't provide an authentication header the response should return `null` (or `None` in Python):

```python
# tests/integration/graphql/profile/test_profile_query.py
class TestGraphQLProfileQuery:
    """GraphQL.query.profile"""

    query = "query QueryProfile { profile { id email organizationId } }"

    def test_query_profile_without_token(self, client):
        """[GQL-PFL-01] returns null if no authentication token is provided"""

        json = {"query": self.query}
        response = client.post("/graphql", json=json)

        assert response.status_code == 200

        # confirm no profile has been returned
        result = response.json()
        assert result["data"]["profile"] is None
```

For the next test we need to obtain a valid token that identifies an existing user. We will do this a lot so it's worth setting up a fixture for this. The code below defines the `get_auth_headers` Pytest fixture. This fixture defines and returns a function that - when invoked with an existing user id - will produce the correct `authorization` header for this user. It builds on the existing `dependencies` and `all_users` fixtures to get the correct user and generate a token for this user.

```python
# tests/conftest.py

def get_fixture_by_id(collection, id):
    """return element with given id from collection"""
    for item in collection:
        if item["id"] == id:
            return item
    raise ValueError(f"id '{id}' not found")

@pytest.fixture(scope="session")
def get_auth_headers(dependencies, all_users):
    def get_auth_headers(user_id):
        auth_service = dependencies.services.auth_service()
        user = get_fixture_by_id(all_users, user_id)
        token = auth_service.get_token(AuthUser.parse_obj(user))

        return {"authorization": f"Bearer {token}"}

    return get_auth_headers
```

With the new fixture we can set up a test that takes an existing user (from the `all_users` fixture) and adds the authorization headers for that user to the query. We can add headers to the test client's post request via the `headers` keyword argument. Then we just have to compare the returned profile data with the initial user's data to confirm that the profile is correct.

```python
    def test_query_profile_with_user_token(self, all_users, client, get_auth_headers):
        """[GQL-PFL-02] returns the correct profile data for an authenticated user"""
        user = all_users[3]
        headers = get_auth_headers(user["id"])
        json = {"query": self.query}
        response = client.post("/graphql", headers=headers, json=json)

        assert response.status_code == 200

        # confirm the right user data has been returned as profile
        result = response.json()
        profile = result["data"]["profile"]

        assert profile["id"] == user["id"]
        assert profile["email"] == user["email"]
        assert profile["organizationId"] == user["organization_id"]
```

## Use Case with Authenticated User

We now have a way to authenticate a user who's making a requests. Let's update our `ListUsersUseCase` logic to use that information and tailor the response based on the user's role and identity.

TODO
