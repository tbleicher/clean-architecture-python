# 6b. Authentication Middleware

With the `login` mutation implemented in the last step [06a. Authentication Token](./06a_authentication.md) the user can request an _access token_ that identifies them in further requests. When this token is included in a request header, the server can extract it and use the information within to identify the user. This feature is usually implemented as _middleware_ in the web framework. In this chapter we will add such a middleware to our FastAPI server.

## Token Middleware

You can find some background on [FastAPI middleware on their website](https://fastapi.tiangolo.com/tutorial/middleware/). Here is the first paragraph outlining the sequence of a middleware call (the emphasis is mine and not the one used on the FastAPI web site):

1. It takes **each** request that comes to your application.
2. It can then **do something to** that request or run any needed code.
3. Then it passes the request to be processed by the rest of the application (by some path operation).
4. It then takes the response generated by the application (by some path operation).
5. It can do something to that response or run any needed code.
6. Then it returns the response.

For our authentication use case the first two points are important:

Firstly, middleware runs for _every single request_ that the server receives. It is common to implement authentication middleware in a way that rejects a request if a token is not provided. We are not going to do that. In our _Clean Architecture_ approach only the use cases can decide if a request is authorised or not. If we want to expose some endpoints to unauthorised users we have to let all requests past the HTTP and GraphQL layers to reach the use cases.

Note that you can reject requests without token if your application does not contain any publicly available endpoints. You have to supply a different method for the user to obtain the token, like a 3rd party service.

Secondly, middleware can update the request before it is processed by a route handler. Our middleware will extract the user information from a potential token and attach it to the request so that the following layers do not have to deal with the token details but can just check if details of the requesting user are available or not.

I think this makes best use of the potential of a token: It provides us with basic user information but avoids a DB lookup to load this information. If a use case requires additional information beyond the token data we can implement the lookup within the use case itself.

### Implementing Middleware in FastAPI

In FastAPI middleware is implemented as a _decorator_. Based on the FastAPI code example a _middleware_ receives two arguments:

- the _request_
- a _call_next_ function

The middleware can update the _request_, use _call_next_ to obtain the _response_ and update the response before returning it. We are only interested in processing the request. The response we return unchanged. The setup for our authentication middleware needs to be at the top level of the app in `main.py`:

```python
# app/main.py

@app.middleware("http")
async def session(request: Request, call_next):
    try:
        request = await get_token_user(request)
    except Exception as exc:
        logging.error(exc)

    response = await call_next(request)
    return response
```

The processing of the request is implemented in the `get_token_user` function:

1. We try to extract a token from the `authorization` header of the request. If there is no header we return an empty string.
2. We set up another use case to interpret the token and return a `SessionUser` object. If we get one, it is added to the `request.state`.
3. If anything goes wrong we set `request.state.user` to `None`. So we can always check `request.state.user` without AttributeError, but still need to check that the user object is not `None`.
4. Finally we return the request object for further processing.

```python
# app/adapters/http/middleware/get_token_user.py

from app.domain.auth.use_cases import GetSessionUserUseCase

def get_token_from_header(request: Request) -> str:
    """return auth token from request headers"""
    try:
        auth_header = request.headers["authorization"]
    except KeyError:
        return ""

    if auth_header.lower().startswith("bearer "):
        return auth_header.split(" ")[1]

    return auth_header

async def get_token_user(request: Request) -> Request:
    """add session user from auth token to request"""
    try:
        token = get_token_from_header(request)
        use_case = GetSessionUserUseCase()
        request.state.user = await use_case.execute(token)
    except KeyError:
        request.state.user = None

    return request
```

### _GetSessionUserUseCase_

The _GetSessionUserUseCase_ implements no logic. The `execute` method just passes the token to the `get_session_user_from_token` method of the AuthService to process. If this call fails - for example, because the token is expired - we would receive no session user entity so the return type has to be specified as `Optional[SessionUser]`.

The method is set up as `async` although we are not doing anything that requires `await`ing. Should you wish to look up extra data for the user from a DB or other external source you can implement it here without blocking other requests.

```python
# app/domain/auth/use_cases/session.py
class GetSessionUserUseCase:
    """identify and return user from request token"""

    @inject
    def __init__(
        self,
        auth_service: AuthServiceInterface = Provide[AppDependencies.services.auth_service],  # type: ignore
    ):
        self.auth_service: AuthServiceInterface = auth_service

    async def execute(self, token: str) -> Optional[SessionUser]:
        """return list of groups in the same organization"""
        session_user = self.auth_service.get_session_user_from_token(token)
        # optional: implement async user data lookup here
        return session_user
```

### Getting the Session User from the Token

When we created our token in the `AuthService.get_token` method, we used an instance of the _SessionUser_ entity to generate the user data for the token payload. We can reverse this and create an new _SessionUser_ instance from the token data.

At first we need to decode the raw token string with the correct signing secret to verify that it is one of our own tokens we are processing. When we receive the decoded data (a nested Python `dict`) we can find the user data under the `user` key. Based on this data we can instantiate a new _SessionUser_ object and return it to the caller.

All this should work without a hitch if we are dealing with one of our own access tokens. If there is an error it's a sign of an incorrect or incomplete token string. In that case we just return `None` and the request will be treated like an anonymous requests without authenticated user.

```python
# app/domain/auth/service.py
    def get_session_user_from_token(self, token: str) -> Optional[SessionUser]:
        """extract user data from session token"""
        algorithm = self.config["algorithm"]
        secret = self.config["secret"]

        try:
            decoded = jwt.decode(token, secret, algorithms=[algorithm])
            session_user = SessionUser(**decoded["user"])
            return session_user
        except Exception:
            return None
```

We now have our session user that is handed back to the middleware where it is set up as the `request.state.user` object. Every GraphQL resolver that needs to provide the requesting user to a use case can get check this attribute and pass it as argument to the `execute` method.

## Profile Query

For a quick example we can add a `profile` endpoint to our schema that returns the current user profile or `null` if the user is not logged in.

We will add a new `UserProfile` entity to identify the content of the returned data clearly. We could just return a `SessionUser` object but that would undermine the meaning of the data type and we would have to change it if we decide in the future that we want to add some extra data to the profile.

```python
# app/domain/users/entities.py

class UserProfile(BaseModel):
    """profile data for the currently logged in user"""

    id: str
    email: str
    organization_id: str
    is_admin: bool

    class Config:
        allow_mutation = False
```

To save time we won't implement a lot of logic to generate the profile data. We will just return the data that is provided by the session user object. This object is passed in as argument `current_user` to the `execute` method. Therefore we don't have any dependencies that need to be injected in the use case constructor.

```python
from typing import Optional
from ..entities import SessionUser, UserProfile

class GetUserProfileUseCase:
    """return the current user's profile data"""

    async def execute(
        self, current_user: Optional[SessionUser] = None
    ) -> Optional[UserProfile]:
        if not current_user:
            return None

        return UserProfile(**current_user.dict())
```

The `UserProfile` entity requires a corresponding GraphQL type. It has the same set of attributes and we know that all of them will be present so we can mark them as required fields. While the attributes of the `UserProfile` type can be required, the `profile` field itself must be optional. If an unauthenticated visitor queries the `profile` endpoint they should just receive `null` instead of an error.

```python
# app/adapters/graphql/types/users.py

class UserProfile(graphene.ObjectType):
    class Meta:
        description = "Details of the current user"

    id = graphene.ID(required=True)
    email = graphene.String(required=True)
    organization_id = graphene.String(required=True)
    is_admin = graphene.Boolean(required=True)

# app/adapters/graphql/query.py
class Query(graphene.ObjectType):
    # ... other attributes and methods

    profile = graphene.Field(types.UserProfile)

    @staticmethod
    async def resolve_profile(parent, info):
        return await resolvers.get_user_profile(info)
```

In the `resolve_profile` method we call a new `get_user_profile` resolver to interact with the use case. The `get_user_profile` resolver will not only set up and execute the use case. It also needs to extract the `SessionUser` object from the GraphQL execution `info` - if it is present.

In our middleware we attach the user data as `request.state.user`. In the `info` object we can find this attribute under `info.context["request"]["state"]["user"]`. We can be sure that this key is set because the middleware either sets it to the `SessionUser` object or `None` if the token is not provided or invalid.

```python
# app/adapters/graphql/resolvers/users.py
from app.domain.users.entities import UserProfile
from app.domain.users.use_cases import GetUserProfileUseCase

async def get_user_profile(info) -> Optional[UserProfile]:
    """get use profile from current user in session info"""
    current_user = info.context["request"]["state"]["user"]
    use_case = GetUserProfileUseCase()
    return await use_case.execute(current_user)

# ... other resolvers
```

`info.context["request"]["state"]["user"]` is quite a mouth full and we have to add the user data to (almost) all of our endpoints. We can define a helper function to get the current user from the `info` object:

```python
# app/adapters/graphql/helpers.py
from typing import Any, Optional
from app.domain.users.entities import SessionUser

def get_current_user(info: Any) -> Optional[SessionUser]:
    current_user = info.context["request"]["state"]["user"]
    return current_user
```

## Testing

The `profile` query endpoint is now in place and we can make our first query. Unfortunately, the `GraphiQL` interface that FastAPI/Starlette provides does not have an option to set request headers. So from here on we have to rely on our automated integration tests to set the right authentication header for our queries. In this section we will set up Pytest fixtures to obtain authentication tokens and update our tests to use them.

### Manual Testing

Before we update our test suite, let's first verify that the endpoint is working as expected. We can use the command line tool `curl` to send our credentials to the `login` endpoint and obtain a token as response:

```bash
$ curl \
  -H "Content-Type: application/json" \
  -d '{ "query": "mutation { login(input: { email: \"admin@example.com\", password: \"password\" }) { token } }" }' \
  http://localhost:8000/graphql

{"data":{"login":{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJVU0VSLUFETSIsInVzZXIiOnsiaWQiOiJVU0VSLUFETSIsImVtYWlsIjoiYWRtaW5AZXhhbXBsZS5jb20iLCJvcmdhbml6YXRpb25faWQiOiIiLCJpc19hZG1pbiI6dHJ1ZX0sImV4cCI6MTYxNzc5MTkyOX0.-qQf1pUAYD_sVmDYgvwKb7ti86yY4WDcSrcTapZ4iOs"}}}%
```

Now we can use this token string as a `Authorization` header in a new request to the `profile` endpoint. We have to prefix the token with `Bearer ` to match the expectations of the header format.

```bash
$ curl \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJVU0VSLUFETSIsInVzZXIiOnsiaWQiOiJVU0VSLUFETSIsImVtYWlsIjoiYWRtaW5AZXhhbXBsZS5jb20iLCJvcmdhbml6YXRpb25faWQiOiIiLCJpc19hZG1pbiI6dHJ1ZX0sImV4cCI6MTYxNzc5MTkyOX0.-qQf1pUAYD_sVmDYgvwKb7ti86yY4WDcSrcTapZ4iOs" \
  -d '{ "query": "query { profile { id email } }" }' \
  http://localhost:8000/graphql

{"data":{"profile":{"id":"USER-ADM","email":"admin@example.com"}}}%
```

As expected, the returned data identifies the user as `admin@example.com`. Our `profile` endpoint works!

### Authentication Token for Automated Testing

Now that we have confirmed that the `profile` query endpoint works we can add automated tests. For this endpoint we need to test two scenarios:

- **[GQL-PFL-01]** `profile` returns `null` when queried without token
- **[GQL-PFL-02]** `profile` returns the correct profile data for an authenticated user

The first test is easy. We just use our test client to make a query to the `profile` endpoint. Since we don't provide an authentication header the response should return `null` (or `None` in Python):

```python
# tests/integration/graphql/profile/test_profile_query.py
class TestGraphQLProfileQuery:
    """GraphQL.query.profile"""

    query = "query QueryProfile { profile { id email organizationId } }"

    def test_query_profile_without_token(self, client):
        """[GQL-PFL-01] returns null if no authentication token is provided"""

        json = {"query": self.query}
        response = client.post("/graphql", json=json)

        assert response.status_code == 200

        # confirm no profile has been returned
        result = response.json()
        assert result["data"]["profile"] is None
```

For the next test we need to obtain a valid token that identifies an existing user. We will do this a lot so it's worth setting up a fixture for this. The code below defines the `get_auth_headers` Pytest fixture. This fixture defines and returns a function that - when invoked with an existing user id - will produce the correct `authorization` header for this user. It builds on the existing `dependencies` and `all_users` fixtures to get the correct user and generate a token for this user.

```python
# tests/conftest.py

def get_fixture_by_id(collection, id):
    """return element with given id from collection"""
    for item in collection:
        if item["id"] == id:
            return item
    raise ValueError(f"id '{id}' not found")

@pytest.fixture(scope="session")
def get_auth_headers(dependencies, all_users):
    def get_auth_headers(user_id):
        auth_service = dependencies.services.auth_service()
        user = get_fixture_by_id(all_users, user_id)
        token = auth_service.get_token(AuthUser.parse_obj(user))

        return {"authorization": f"Bearer {token}"}

    return get_auth_headers
```

With the new fixture we can set up a test that takes an existing user (from the `all_users` fixture) and adds the authorization headers for that user to the query. We can add headers to the test client's post request via the `headers` keyword argument. Then we just have to compare the returned profile data with the initial user's data to confirm that the profile is correct.

```python
    def test_query_profile_with_user_token(self, all_users, client, get_auth_headers):
        """[GQL-PFL-02] returns the correct profile data for an authenticated user"""
        user = all_users[3]
        headers = get_auth_headers(user["id"])
        json = {"query": self.query}
        response = client.post("/graphql", headers=headers, json=json)

        assert response.status_code == 200

        # confirm the right user data has been returned as profile
        result = response.json()
        profile = result["data"]["profile"]

        assert profile["id"] == user["id"]
        assert profile["email"] == user["email"]
        assert profile["organizationId"] == user["organization_id"]
```

## Use Case with Authenticated User

We now have a way to authenticate a user who's making a requests. Let's incorporate this information in the logic to use that information and tailor the response based on the user's role and identity.

Currently the `ListUsersUseCase` returns a list of all users, regardless of the user who is making the request. We can refine our requirements and define the expected response based on the information we have about the user:

- **[GQL-US-001]** `users` returns an empty list when the current user is not authenticated
- **[GQL-US-002]** `users` returns a list of all users when the current user is an admin
- **[GQL-US-003]** `users` returns a list of users in the same organisation as the current user

### Users List without Access Token

We can adapt the current (temporary) test for our `users` GraphQL endpoint to test the first requirement. In the test case we do not provide authentication headers so all we need to change is the assertion in the last line where we now check that the `users` array has a length of 0.

```python
# tests/integration/graphql/users/test_users_query.py
    def test_query_users_list_without_token(self, client):
        """[GQL-US-001] returns an empty list without token"""
        json = {"query": self.query}
        response = client.post("/graphql", json=json)

        assert response.status_code == 200

        result = response.json()
        assert len(result["data"]["users"]) == 0
```

This test will now fail. We still return the full list of users so our expected result does not match the actual. We need to update the use case itself to return an empty list when the caller does not provide a `SessionUser` instance for the current user. We also need to update the signature of the `execute` method to accept the `current_user` as optional argument.

```python
    async def execute(self, current_user: SessionUser = None) -> List[User]:
        if not current_user:
            return []

        return await self.user_service.find_all()
```

Now we can run the test again and confirm that is passes.

### Users List as Admin User

When we query the users list as user with admin privileges we want to get a list of all users as before. An admin user is a user who has the `is_admin` flag set to `true`. In our test fixtures there is one admin user with the user id `USER-ADM`.

Our test case setup merges the authentication header from the `profile` endpoint test with assertion that all users are returned from the original users listing:

```python
# tests/integration/graphql/users/test_users_query.py
    def test_query_users_list_as_admin(self, all_users, client, get_auth_headers):
        """[GQL-US-002] returns a list of all users when queried as admin"""
        headers = get_auth_headers("USER-ADM")
        json = {"query": self.query}
        response = client.post("/graphql", headers=headers, json=json)

        assert response.status_code == 200

        result = response.json()
        assert len(result["data"]["users"]) == len(all_users)
```

This test will fail at this point although we provide the correct authorization header. The reason is that we are not passing this information on from the GraphQL resolver to the use case. First we need to update the resolver to take the query `info` object as argument, extract the `current_user` from it and pass this object to the use case:

```python
# app/adapters/graphql/query.py
    @staticmethod
    async def resolve_users(parent, info):
        return await resolvers.list_users(info)

# app/adapters/graphql/resolvers/users.py
async def list_users(info) -> List[User]:
    """call ListUsersUseCase.execute() with current_user as argument"""
    current_user = get_current_user(info)
    use_case = ListUsersUseCase()
    return await use_case.execute(current_user)
```

This is all we need to do to make both tests pass. Although we don't yet check if the user is an admin, we still return the full list of users as the default response in our use case. This is - by chance - the correct response for an admin user and so the test passes.

### Users List as Regular User

Exposing a list of all of our users to anyone who is logged in is not our final implementation. We want to limit a regular user's view of other users to those that are members of the same organisation _unless_ the user is an admin. In our users fixture we have two organizations:

- **Shoestring Ltd** with 7 members (id: `GROUP-SHOESTRING-LTD`)
- **Big Bucks** with 3 members (id: `GROUP-BIG-BUCKS`)

So a member of _Shoestring Ltd_ should see a list of 7 users, a member of _Big Bucks_ should see 3. We can set up a combination of a user id and the expected count for each group and iterate over the combinations in our test:

```python
# tests/integration/graphql/users/test_users_query.py
    def test_query_users_list_as_user(self, client, get_auth_headers):
        """[GQL-US-003] returns a list of users in the current user's organisation"""
        combinations = [["USER-CLOE", 7], ["USER-BIG-STEVE", 3]]

        for user_id, count in combinations:
            headers = get_auth_headers(user_id)
            json = {"query": self.query}
            response = client.post("/graphql", headers=headers, json=json)

            assert response.status_code == 200

            result = response.json()
            assert len(result["data"]["users"]) == count
```

We can run this test now and check the error message. The test will fail because we receive too many users. So far our use case does not check if a logged in user is an admin or not. It just confirms the presence of a `SessionUser` object. So the first thing we need to change is to show the list of all users only when the current user is an admin:

```python
# app/domain/users/use_cases/list_users.py
    async def execute(self, current_user: SessionUser = None) -> List[User]:
        if not current_user:
            return []

        if current_user.is_admin:
            return await self.user_service.find_all()

        return []
```

Note that I also return an empty list as the default response. Without this the Python type validation will fail because we always have to return a list from the `execute` method.

Now our previous two tests still pass but and the current test fails because we do not return any users. We can get the correct list of users by searching our user repository for all users that have the same `organization_id` than the current user.

The _UserService_ provides the `find_users_by_attributes` method to filter the list of users to those with the given attributes. For this use case we want to match the `organization_id` to that of the `current_user`. This search will always return a list so we can use it as the default response of our `execute` method. Here is the complete code:

```python
# app/domain/users/use_cases/list_users.py
    async def execute(self, current_user: SessionUser = None) -> List[User]:
        if not current_user:
            return []

        if current_user.is_admin:
            return await self.user_service.find_all()

        attributes = {"organization_id": current_user.organization_id}
        return await self.user_service.find_users_by_attributes(attributes)
```

With this addition all of our requirements are met and our integration tests pass but the temporary unit test `DOM-UC-US-LST-00` for the `ListUsersUseCase` will fail.

### UseCase Unit Tests

Let's review how the _unit_ test is currently implemented:

```python
# tests/unit/domain/users/use_cases/test_list_users.py

    @pytest.mark.asyncio
    async def test_use_case_list_users(self, mock_user_service):
        """[DOM-UC-US-LST-00] ListUsersUseCase calls user_service.find_all"""

        mock_user_service.find_all = AsyncMock()

        use_case = ListUsersUseCase(user_service=mock_user_service)
        await use_case.execute()

        mock_user_service.find_all.assert_awaited()
```

We test that the use case calls the `find_all` method of the _UserService_ but we do not provide a `current_user` argument when we call it. In that case we bypass the service and just return an empty list. In fact, `find_all` is now only called when the current user is an admin. To cover all of our code branches we need to test three conditions:

- use case is called without _current_user_
- use case is called by a regular user
- use case is called by an admin user

In the first case we just need to check that the return value of the call is an empty list. We don't really care how the use case gets it but if it would call any method on the user service it would raise a `NotImplementedError`. We can also update the test description and give it a permanent id.

```python
# tests/unit/domain/users/use_cases/test_list_users.py

    @pytest.mark.asyncio
    async def test_use_case_list_users_without_current_user(self, mock_user_service):
        """[DOM-UC-US-LST-01] ListUsersUseCase return empty list without current user"""
        use_case = ListUsersUseCase(user_service=mock_user_service)
        result = await use_case.execute()

        assert result == []
```

For the second test we first need to set up a `SessionUser` entity. It does not matter if a corresponding user exists in our fixtures. We are not interested in the search result for a given user. We just want to test that the use case uses the right query options to find them.

The query attribute is the user's `organisation_id`. We can set this up as the _expected_ value and use the `AsyncMock.assert_awaited_with` method to confirm that `UserService.find_users_by_attributes` has been called with this value:

```python
# tests/unit/domain/users/use_cases/test_list_users.py

    @pytest.mark.asyncio
    async def test_use_case_list_users_with_regular_user(self, mock_user_service):
        """[DOM-UC-US-LST-02] ListUsersUseCase searches users by organisation_id when called by a regular user"""

        mock_user_service.find_users_by_attributes = AsyncMock()
        current_user = SessionUser(
            id="user-id",
            email="user@example.com",
            organization_id="example-org-id",
            is_admin=False,
        )
        expected = {"organization_id": current_user.organization_id}

        use_case = ListUsersUseCase(user_service=mock_user_service)
        await use_case.execute(current_user)

        mock_user_service.find_users_by_attributes.assert_awaited_with(expected)
```

Finally, when the current user is an admin we expect that the `find_all` method of the UserService is called. This is our original test but with an added _current_user_ argument.

```python
# tests/unit/domain/users/use_cases/test_list_users.py

    @pytest.mark.asyncio
    async def test_use_case_list_users_with_admin_user(self, mock_user_service):
        """[DOM-UC-US-LST-03] ListUsersUseCase returns all users when called by an admin"""

        mock_user_service.find_all = AsyncMock()
        current_user = SessionUser(
            id="user-id",
            email="user@example.com",
            organization_id="example-org-id",
            is_admin=True,
        )

        use_case = ListUsersUseCase(user_service=mock_user_service)
        await use_case.execute(current_user)

        mock_user_service.find_all.assert_awaited()
```

Now _all_ test should be green.

## Review

We can see in this small example that we are able to implement our requirements in a few simple lines of code if we focus on the logic alone. By striping away transport and data access concerns the use case becomes a condensed expression of our business logic.

Admittedly, this is a simple example. If our requirements become more complex, the use case will unavoidably increase in size. But that does not mean that the code has to become difficult to understand. We still can express our logic as a sequence of conditions and return the right selection of users if a condition is met.

## Refactoring Auth Fixtures

In our tests we used the `get_auth_headers` fixture to obtain headers for an individual user. We will use this frequently and typically write tests involving an admin user and a 'typical' user. Specifying their ids throughout many tests is repetitive and we are better off if we define a dedicated fixture for each user:

```python
# tests/conftest.py
@pytest.fixture(scope="session")
def auth_headers(get_auth_headers):
    return get_auth_headers("USER-CLOE")


@pytest.fixture(scope="session")
def admin_auth_headers(get_auth_headers):
    return get_auth_headers("USER-ADM")
```

Whenever we need to make an authenticated request we can add one of these fixtures to the dependencies of the test case and just add them as `headers` keyword argument to the test client call. For tests where we need a specific user's credentials we can still use the `get_auth_headers` fixture.
